# V2: No-Pools Mode & Multi-Division Support

## Context

The scheduler currently assumes exactly 2 pools ("north"/"south") with intra-pool rounds on weekdays and crossover rounds on weekends. Two enhancements are needed:

1. **No-pools mode**: When the config has no `pools:` section, all teams form a single round-robin. No intra/crossover distinction — just rounds distributed across weekday and weekend slots.

2. **Multi-division**: A single config defines multiple divisions (e.g., D1, D2, D3). Each division has its own teams, optional pools (always north/south if present), and independent round-robin scheduling — but they **share physical fields** (no double-booking across divisions).

**Key constraint**: Pools are always either absent or exactly north/south. No need to generalize to N arbitrary pools — just handle the two cases: "has pools" (north/south, exactly as today) and "no pools" (single round-robin).

## Config Format

### Current (backward compatible — still works)
```yaml
pools:
  north: [PAC1, PAC2, ...]
  south: [ALP1, ALP2, ...]
```

### No-pools (Feature 1)
Omit the `pools:` section entirely. All teams go into a single round-robin.

### Multi-division (Feature 2)
```yaml
divisions:
  D1:
    teams: [ALP1, ALP2, PA1, PA2, RWC1, RWC2]
    pools:
      north: [ALP1, ALP2]
      south: [PA1, PA2, RWC1, RWC2]
  D2:
    teams: [ALP3, PA3, RWC3, RWC4]
    # no pools = single round-robin
```

### Backward compatibility matrix

| Config has | Behavior |
|---|---|
| `pools:` (no `divisions:`) | Today's behavior: 2 pools, intra + crossover |
| Neither `pools:` nor `divisions:` | No pools, all teams, one round-robin |
| `divisions:` | Multi-division, each with own pools (or none) |

---

## Phase 1: No-Pools Mode

Add a conditional path: if `pools:` is present, everything works as today. If absent, generate a single round-robin and distribute rounds across both weekday and weekend slots.

### `config.py` (lines 76-81, 133-146)
- **Pool loading**: Move league parsing BEFORE pool parsing so `all_team_codes` is available. Make pools optional:
  ```python
  if "pools" in raw:
      pools = {
          "north": list(raw["pools"]["north"]),
          "south": list(raw["pools"]["south"]),
      }
      all_team_codes = set(pools["north"] + pools["south"])
  else:
      pools = {}
      # all_team_codes built from leagues below
  ```
  After league parsing, if pools is empty: `all_team_codes = set(team_to_league.keys())`
- **Team construction (line 133)**: When pools exist, loop as today. When no pools:
  ```python
  if pools:
      for pool_name in ("north", "south"):
          for code in pools[pool_name]:
              teams[code] = Team(..., pool=pool_name, ...)
  else:
      for code in all_team_codes:
          teams[code] = Team(..., pool="", ...)
  ```
- **`all_team_codes` validation**: Skip the "team not in any pool" warning when no pools.

### `scheduler.py` — `schedule()` (lines 1387-1406)
Add conditional for the two modes:
```python
pools = config["pools"]
has_pools = bool(pools)

if has_pools:
    # Today's path — unchanged
    north = pools["north"]
    south = pools["south"]
    intra_north = generate_round_robin(north, seed=seed)
    intra_south = generate_round_robin(south, seed=...)
    crossover_north = [t for t in north if not teams[t].weekday_only]
    crossover = generate_crossover(crossover_north, south, seed=...)
else:
    # No-pools: single round-robin, no crossover
    all_team_list = sorted(teams.keys())
    all_rounds = generate_round_robin(all_team_list, seed=seed)
    intra_north = []
    intra_south = []
    crossover = []
    # Split rounds between weekday and weekend slots
    # (handled in assign_rounds_to_slots)
```

### `scheduler.py` — `assign_rounds_to_slots()` (lines 130-278)
Add `no_pool_rounds: list[Round] | None = None` parameter. When provided (no-pools mode):
- **Weekday**: assign one round per weekday slot (instead of one north + one south per slot)
- **Weekend**: assign remaining rounds to weekend slots (instead of crossover rounds)
- Reuse existing `_place_round` / `_score_round` / `_fill_from_deferred` logic — just different input lists.

```python
if no_pool_rounds is not None:
    # No-pools mode: distribute all rounds across weekday + weekend
    n_wd = len(weekday_slots)
    weekday_rounds = no_pool_rounds[:n_wd]
    weekend_rounds_extra = no_pool_rounds[n_wd:]
    # Assign weekday rounds using same blackout-first scoring
    # Assign weekend_rounds_extra to weekend slots (same logic as crossover)
```

### `scheduler.py` — `_invent_games()` (lines 346-413)
When no pools (`has_pools` is False or pool is empty string):
- **Weekend ad-hoc**: pair by least-played (no cross-pool preference since there are no pools)
- **Weekday ad-hoc**: pair by least-played (no same-pool restriction)

```python
if slot_type == "weekend" and has_pools:
    # Cross-pool pairs first, then same-pool remainder (existing logic)
    idle_north = [t for t in idle if teams[t].pool == "north"]
    idle_south = [t for t in idle if teams[t].pool == "south"]
    ...existing cross-pool code...
elif slot_type == "weekday" and has_pools:
    # Same-pool pairs only (existing logic)
    for pool_group in ("north", "south"):
        ...existing same-pool code...
else:
    # No pools (any slot type): all-pairs by least-played
    candidates = []
    for i, t1 in enumerate(idle):
        for t2 in idle[i + 1:]:
            key = (min(t1, t2), max(t1, t2))
            candidates.append((global_matchup_counts[key], t1, t2))
    candidates.sort()
    for _, t1, t2 in candidates:
        if t1 not in used and t2 not in used:
            pairs.append((t1, t2))
            used.add(t1)
            used.add(t2)
```

### `constraints.py` (lines 35-36, 110-120)
Make pool membership conditional:
```python
north = set(pools.get("north", []))
south = set(pools.get("south", []))

# Skip intra/crossover validation when no pools
if north and south:
    if game.game_type == "intra":
        if not (h in north and a in north) and not (h in south and a in south):
            warnings.append(...)
    elif game.game_type == "crossover":
        if (h in north and a in north) or (h in south and a in south):
            warnings.append(...)
```

### `stats.py` (lines 14-15, 121-122)
Make pool sets conditional:
```python
north = set(pools.get("north", []))
south = set(pools.get("south", []))
```
Return values: keep `"north"` and `"south"` keys (will be empty sets when no pools). All downstream code already handles empty sets.

### `output_html.py`
- **`_round_label()` (line 37-45)**: When no pools, return `R{n}` (no N/S prefix). Already handles ad-hoc as "AH".
  ```python
  if not pools:
      return f"R{game.round_number}"
  ```
- **Legend (line 168)**: Omit cross/intra legend when no pools.
- **TOC (lines 177-194)**: When no pools, use the fallback flat list (already exists at line 195-196). Just make sure it triggers when `pools == {}`.
- **Master schedule emoji column**: When no pools, omit the cross/intra emoji and adjust colspan. Already has the column — just conditionally skip it.

### `config_report.py` (lines 79-84, 247)
- **`league_pools` dict (line 79-84)**: When pools is empty, skip pool assignment. League header shows just "N teams" without pool name.
- **HTML TOC (line 247)**: When no pools, use flat league list (no pool grouping).

### `models.py` (line 71)
Update comment: `pool: str  # "north", "south", or "" (no pools)`

### `verify.py`
Already generic — `game_type` derived from pool comparison. With no pools, all games would be same type. No change needed.

---

## Phase 2: Multi-Division Support

### `config.py` — new parsing path
When `divisions:` key exists in YAML:
1. Parse all leagues as today (unchanged)
2. For each division, read its `teams:` list and optional `pools:`
3. Build per-division config: `{div_name: {"teams": {...}, "pools": {...}, "leagues": {...}}}`
4. Leagues are shared — a league's teams can span divisions. Each division gets the subset of league teams in its division.
5. Return structure adds `"divisions"` key. For backward compat, single-division configs still populate top-level `"teams"`, `"leagues"`, `"pools"`.

### `scheduler.py` — orchestration
Add `schedule_multi()` that wraps `schedule()`:
```python
def schedule_multi(config, seed=None):
    divisions = config.get("divisions")
    if not divisions:
        return {"default": schedule(config, seed=seed)}

    all_used_fields = set()  # shared across divisions
    results = {}
    for div_name, div_config in divisions.items():
        div_games, used = schedule_division(
            div_config, seed=seed,
            external_field_bookings=all_used_fields,
        )
        all_used_fields.update(used)
        results[div_name] = div_games
    return results
```

### `scheduler.py` — `assign_games()` field sharing
- Add `external_field_bookings: set | None = None` parameter
- Initialize `used_field_slots` from external bookings
- Return the final `used_field_slots` set so it can be accumulated

### `schedule.py` — main entry point
Call `schedule_multi()` when divisions are present. Pass per-division game lists to output functions.

### Output
- Each division gets its own section in the HTML (master schedule, per-league schedules)
- Game codes are sequential across all divisions (G1, G2, ...)
- Stats and validation per-division
- GameChanger CSV: all games combined, sorted by date

### Constraints
- Per-division validation runs independently
- Cross-division field double-booking check

---

## Files to modify (summary)

| File | Phase 1 (No-Pools) | Phase 2 (Multi-Division) |
|---|---|---|
| `config.py` | Make pools optional, reorder parse | Parse `divisions:` |
| `models.py` | Update pool comment | Add `division: str = ""` to Game |
| `scheduler.py` | Conditional in `schedule()`, `assign_rounds_to_slots()`, `_invent_games()` | `schedule_multi()`, `external_field_bookings` |
| `constraints.py` | Skip intra/crossover check when no pools | Cross-div field check |
| `stats.py` | Safe `.get()` for pools | Per-division stats |
| `output_html.py` | Conditional round labels, legend, TOC, emoji column | Division sections |
| `config_report.py` | Skip pool label when no pools | Division sections |
| `verify.py` | No change needed | — |
| `schedule.py` | — | Call `schedule_multi()` |

## Verification

### Phase 1
1. `python -m pytest tests/ -q` — all tests pass
2. `python schedule.py --seed 42 --output-prefix test_output` — identical output to before (existing config has north/south pools)
3. Create a test config with no `pools:` section (e.g., 6 teams, 3 leagues)
4. Run scheduler — produces a single round-robin, rounds distributed across weekday and weekend slots
5. HTML output: no pool headers, no cross/intra emojis, round labels are R1/R2/R3
6. All teams play each other exactly once
7. Weekday-only teams only appear in weekday slots

### Phase 2
1. Create a test config with `divisions:` (e.g., D1 with pools, D2 without)
2. Run scheduler — each division scheduled independently, no field conflicts across divisions
3. HTML output: separate sections per division
4. Field slot utilization grid shows no double-bookings
